\section{Introduzione}
Quando si sviluppa un software complesso, diventa necessario pianificare il lavoro da svolgere per creare un prodotto robusto e affidabile.\\
In questa sezione discuteremo dei metodi utilizzati per migliorare lo sviluppo del software, come il sistema di versionamento utilizzato e gli strumenti di pulizia del codice usati per ottenere un prodotto di alta qualità.\\
\section{Versionamento del codice}
È deciso di adottare il sistema di versionamento Git, usando la piattaforma GitHub per ospitare il repository del progetto. Essendo l'applicazione divisa in due blocchi precisi e distinti, il Front end Vue e il Server Backend Spring Boot, sono stati creati due repository per gestirli in modo separato ed evitare maggiori conflitti durante lo sviluppo.\\
Il Team di sviluppo si è coordinato per lavorare su funzionalità separate, in modo da ridurre al minimo i conflitti di merge e facilitare l'integrazione del codice, seguendo le seguenti pratiche:\\
\begin{itemize}
    \item \textbf{Commit Frequency:} Si è deciso di effettuare commit frequenti con messaggi chiari e descrittivi, in modo da tracciare facilmente le modifiche apportate al codice.
    \item \textbf{Code Reviews:} Prima di unire una pull request al branch principale, un altro membro del team esegue una revisione del codice per garantire la qualità e la coerenza con gli standard di codifica stabiliti.
\end{itemize}
\newpage
Nelle figure \ref{fig:resoconto-commit-backend} e \ref{fig:resoconto-commit-frontend} sono riportati i resoconti dei commit effettuati su entrambi i repository durante il periodo di sviluppo.
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{"Immagini/Resoconto Commit BE.png"}
	\caption[Resoconto Commit Backend]{}
	\label{fig:resoconto-commit-backend}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{"Immagini/Resoconto Commit FE.png"}
	\caption[Resoconto Commit Frontend]{}
	\label{fig:resoconto-commit-frontend}
\end{figure}
\newpage
\section{Strumenti di pulizia del codice}
Per garantire la qualità del codice e mantenere uno standard elevato, é stato utilizzato uno strumento di pulizia del codice chiamato SonarQube. 	\\
Facendo analisi statiche del codice a intervalli regolari, abbiamo mantenuto un alto rigore qualitativo negli standard forniti dal cliente.\\
Si é fatto uso sia della versione Comunity di SonarQube, istallata in un container Docker locale, che di plugin che si interfacciavano automaticamente con l'IDE per agire in tempo reale durante la scrittura del codice.\\
Nelle figure \ref{fig:sonarqube-overview} e \ref{fig:sonarqube-registo-attivita} viene mostrato lo stato dell'applicazione al suo completamento. Visto che requisiti indicavano un uso limitato dei test automatici, l'analisi si é concentrata principalmente su code smells, vulnerabilità, duplicazione e bug, il quale é riflesso nel resoconto allegato. 
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{"Immagini/Sonarqube-overview.png"}
	\caption[Resoconto SonarQube]{}
	\label{fig:sonarqube-overview}
\end{figure}
\begin{figure}[H]
	\centering
	\includegraphics[width=1\linewidth]{"Immagini/Sonarqube-registo-attivita.png"}
	\caption[Attivitá sul codice SonarQube]{}
	\label{fig:sonarqube-registo-attivita}
\end{figure}
\section{Servizi esterni utilizzati}
In casi dove era necessario utilizzare servizi specializzati, come il salvataggio di file multimediali o la visione di mappe, 
sono stati utilizzati servizzi esterni per facilitare lo sviluppo e migliorare l'affidabilità del prodotto.\\
Per il salvataggio di file multimediali, necessario per visionare le foto di Immobili, 
é stato creato un blob storage container su Microsoft Azure, che offre un servizio scalabile e sicuro per l'archiviazione dei dati.\\
Per la gestione delle mappe, sono state integrate le Geoapify API, 
che forniscono funzionalità avanzate per poter creare un'interfaccia di mappatura per specifiche interazioni con l'utente.\\
L'uso di questi servizi esterni ha permesso di concentrarsi sulle funzionalità principali dell'applicazione,
riducendo i tempi di sviluppo e migliorando la qualità complessiva del prodotto finale.\\

\section{Distribuzione del backend}
Per distribuire l’applicazione server Java Spring Boot, si è proceduto alla containerizzazione tramite \textbf{Docker}, una piattaforma ampiamente diffusa che consente di creare, distribuire ed eseguire applicazioni all’interno di container.
I container sono ambienti isolati che includono tutto il necessario per l’esecuzione dell’applicazione, codice, librerie e configurazioni, garantendo così che il software funzioni in modo coerente su qualsiasi sistema operativo o infrastruttura.

Di seguito viene illustrato il Dockerfile utilizzato per la containerizzazione dell’applicazione.

% === COLORI PERSONALIZZATI ===
\definecolor{bgcolor}{RGB}{245,245,245}    % Sfondo chiaro
\definecolor{keywordcolor}{RGB}{0,0,180}  % Blu per le parole chiave
\definecolor{commentcolor}{RGB}{0,128,0}  % Verde per i commenti
\definecolor{stringcolor}{RGB}{163,21,21} % Rosso per le stringhe
\definecolor{gray}{RGB}{120,120,120}

% === DEFINIZIONE LINGUAGGIO DOCKERFILE ===
\lstdefinelanguage{Dockerfile}{
	morekeywords={
		FROM, RUN, CMD, LABEL, MAINTAINER, EXPOSE, ENV, ADD, COPY, ENTRYPOINT,
		VOLUME, USER, WORKDIR, ARG, ONBUILD, STOPSIGNAL, HEALTHCHECK, SHELL
	},
	sensitive=true,
	morecomment=[l]{\#},             % Commenti con #
	morestring=[b]",                 % Stringhe tra doppi apici
}

% === CONFIGURAZIONE LISTINGS ===
\lstset{
	language=Dockerfile,
	backgroundcolor=\color{bgcolor},
	basicstyle=\ttfamily\small,
	keywordstyle=\color{keywordcolor}\bfseries,
	commentstyle=\color{commentcolor}\itshape,
	stringstyle=\color{stringcolor},
	numbers=left,
	numberstyle=\tiny\color{gray},
	stepnumber=1,
	numbersep=6pt,
	frame=single,
	rulecolor=\color{gray},
	tabsize=4,
	showstringspaces=false,
	breaklines=true,
	captionpos=b,
	literate=
	{à}{{\`a}}1
	{è}{{\`e}}1
	{é}{{\'e}}1
	{ì}{{\`i}}1
	{ò}{{\`o}}1
	{ù}{{\`u}}1
}

\begin{lstlisting}[caption={Esempio di Dockerfile}, label={lst:dockerfile}]
# build del jar
FROM maven:3.9.4-eclipse-temurin-21-alpine AS build
WORKDIR /app

# Copia pom.xml e sorgenti
COPY pom.xml .
COPY src ./src

# Build del jar
RUN mvn clean package -DskipTests

#runtime
FROM eclipse-temurin:21-jdk-alpine
WORKDIR /app

COPY --from=build /app/target/*.jar dietiestetes.jar

ENV SPRING_PROFILES_ACTIVE=prod
ENV SERVER_PORT=8081

ENTRYPOINT ["java","-jar","dietiestetes.jar"]
\end{lstlisting}

